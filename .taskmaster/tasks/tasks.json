{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Verify and audit RLS policies across all tables",
        "description": "Security audit of Row-Level Security policies with different user roles (superintendent, PM, field employee, subcontractor, architect) to ensure proper data isolation and access control",
        "details": "Conduct comprehensive RLS policy verification:\n\n1. **Automated Testing (src/__tests__/security/rls-policies.test.ts)**\n   - Create test users for each role type\n   - Verify project-level isolation\n   - Test company multi-tenancy boundaries\n   - Validate cascade delete behavior\n\n2. **Manual Audit**\n   - Review migration files 012, 022, 147, 149 for RLS policies\n   - Check all 60+ tables have RLS enabled\n   - Verify service_role bypass policies are necessary\n   - Test recursive policy issues (migrations 016-019)\n\n3. **Policy Validation**\n   ```sql\n   -- Query to find tables without RLS\n   SELECT tablename FROM pg_tables \n   WHERE schemaname = 'public' \n   AND tablename NOT IN (\n     SELECT tablename FROM pg_policies\n   );\n   ```\n\n4. **Role-Based Testing**\n   - Superintendent: Access only assigned projects\n   - Subcontractor: View only their scope\n   - Field Employee: Limited write access\n   - Architect: Review permissions only\n\n5. **Security Checklist**\n   - [ ] All user-facing tables have SELECT policies\n   - [ ] INSERT policies validate company_id\n   - [ ] UPDATE/DELETE prevent cross-company modification\n   - [ ] Sensitive tables (users, auth) properly locked down\n   - [ ] Push subscriptions isolated per user",
        "testStrategy": "Run automated RLS test suite with npm run test:security. Create 5 test users representing different roles. Attempt unauthorized access to projects, documents, RFIs, and submittals across company boundaries. Use scripts/sql/check-all-rls-policies.sql to verify policy completeness. Validate with Supabase dashboard policy viewer.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-05T10:23:09.598Z"
      },
      {
        "id": "2",
        "title": "Implement session management improvements",
        "description": "Enhanced session handling with automatic refresh, expiry detection, and graceful recovery from network interruptions",
        "details": "Improve session management for production reliability:\n\n1. **Session Refresh (src/lib/supabase.ts)**\n   ```typescript\n   // Auto-refresh 5 minutes before expiry\n   supabase.auth.onAuthStateChange((event, session) => {\n     if (event === 'TOKEN_REFRESHED') {\n       logger.info('Session refreshed successfully');\n     }\n     if (event === 'SIGNED_OUT') {\n       // Clear IndexedDB, redirect to login\n       clearOfflineData();\n     }\n   });\n   ```\n\n2. **Session Persistence**\n   - Verify localStorage session storage\n   - Test session recovery after browser restart\n   - Handle expired sessions gracefully\n\n3. **Network Interruption Handling**\n   - Queue auth refresh requests during offline\n   - Retry failed refresh attempts (exponential backoff)\n   - Show user-friendly session expiry warnings\n\n4. **AuthContext Enhancement (src/contexts/AuthContext.tsx)**\n   - Add session expiry countdown\n   - Implement \"extend session\" prompt\n   - Handle concurrent tab sync (BroadcastChannel)\n\n5. **Production Considerations**\n   - Set appropriate session timeout (default: 1 hour)\n   - Configure refresh token rotation\n   - Add session hijacking detection\n   - Implement device fingerprinting (optional)",
        "testStrategy": "Test session persistence across browser restarts. Simulate network interruption during auth refresh. Verify automatic refresh 5 minutes before expiry. Test concurrent tab behavior (login in one tab, verify other tabs update). Use DevTools Network throttling to simulate slow connections. Validate session cleanup on logout.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-05T11:52:41.804Z"
      },
      {
        "id": "3",
        "title": "Add rate limiting on authentication endpoints",
        "description": "Implement rate limiting for login, signup, password reset, and MFA endpoints to prevent brute force attacks and abuse",
        "details": "Implement rate limiting using Supabase Edge Functions and Upstash Redis:\n\n1. **Supabase Auth Configuration**\n   - Enable built-in rate limiting in Supabase dashboard\n   - Set login attempts: 5 per 15 minutes per IP\n   - Set signup attempts: 3 per hour per IP\n   - Set password reset: 3 per hour per email\n\n2. **Edge Function Rate Limiter (supabase/functions/_shared/rate-limiter.ts)**\n   ```typescript\n   import { Redis } from '@upstash/redis';\n   \n   export async function checkRateLimit(\n     identifier: string, // IP or user ID\n     action: 'login' | 'signup' | 'password_reset',\n     limits: { max: number; window: number }\n   ): Promise<{ allowed: boolean; remaining: number }> {\n     const redis = new Redis({\n       url: Deno.env.get('UPSTASH_REDIS_URL')!,\n       token: Deno.env.get('UPSTASH_REDIS_TOKEN')!,\n     });\n     \n     const key = `ratelimit:${action}:${identifier}`;\n     const count = await redis.incr(key);\n     \n     if (count === 1) {\n       await redis.expire(key, limits.window);\n     }\n     \n     return {\n       allowed: count <= limits.max,\n       remaining: Math.max(0, limits.max - count),\n     };\n   }\n   ```\n\n3. **Client-Side Handling (src/pages/auth/LoginPage.tsx)**\n   - Display \"Too many attempts\" message\n   - Show countdown timer until retry allowed\n   - Implement CAPTCHA after 3 failed attempts\n\n4. **Rate Limit Configuration**\n   - Login: 5 attempts per 15 min\n   - Signup: 3 attempts per hour\n   - Password reset: 3 per hour\n   - MFA verification: 5 attempts per 5 min\n\n5. **Monitoring & Alerts**\n   - Log rate limit violations to Sentry\n   - Alert on suspicious patterns (>100 attempts/hour from single IP)\n   - Dashboard for rate limit metrics",
        "testStrategy": "Attempt 6 login failures from same IP, verify lockout. Test CAPTCHA appears after 3 failures. Verify countdown timer accuracy. Test rate limits reset after time window. Use multiple IPs to verify isolation. Monitor Sentry for rate limit events. Validate Redis key expiration.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-05T12:08:13.229Z"
      },
      {
        "id": "4",
        "title": "Implement audit logging for sensitive operations",
        "description": "Create comprehensive audit trail for security-critical actions including auth events, permission changes, document access, and data modifications",
        "details": "Build audit logging system for compliance and security:\n\n1. **Audit Log Table (supabase/migrations/170_audit_logging.sql)**\n   ```sql\n   CREATE TABLE audit_logs (\n     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n     user_id UUID REFERENCES auth.users(id),\n     company_id UUID REFERENCES companies(id),\n     action VARCHAR(50) NOT NULL, -- login, logout, create, update, delete, export, access\n     resource_type VARCHAR(50) NOT NULL, -- project, document, rfi, submittal, user\n     resource_id UUID,\n     ip_address INET,\n     user_agent TEXT,\n     old_values JSONB,\n     new_values JSONB,\n     metadata JSONB DEFAULT '{}',\n     created_at TIMESTAMPTZ DEFAULT NOW()\n   );\n   \n   CREATE INDEX idx_audit_logs_user_created ON audit_logs(user_id, created_at DESC);\n   CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);\n   CREATE INDEX idx_audit_logs_action ON audit_logs(action);\n   ```\n\n2. **Audit Events to Track**\n   - **Authentication**: login, logout, failed_login, mfa_setup, password_reset\n   - **Authorization**: role_change, permission_grant, permission_revoke\n   - **Data**: document_view, document_download, export_report, bulk_delete\n   - **Critical Changes**: project_delete, user_delete, rls_policy_change\n\n3. **Database Triggers for Auto-Audit**\n   ```sql\n   CREATE OR REPLACE FUNCTION log_audit_trail()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     INSERT INTO audit_logs (user_id, action, resource_type, resource_id, old_values, new_values)\n     VALUES (\n       auth.uid(),\n       TG_OP, -- INSERT, UPDATE, DELETE\n       TG_TABLE_NAME,\n       COALESCE(NEW.id, OLD.id),\n       to_jsonb(OLD),\n       to_jsonb(NEW)\n     );\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql SECURITY DEFINER;\n   ```\n\n4. **Client-Side Logging (src/lib/audit/audit-logger.ts)**\n   ```typescript\n   export async function logAudit({\n     action,\n     resourceType,\n     resourceId,\n     metadata,\n   }: AuditLogEntry) {\n     await supabase.from('audit_logs').insert({\n       action,\n       resource_type: resourceType,\n       resource_id: resourceId,\n       ip_address: await getClientIP(),\n       user_agent: navigator.userAgent,\n       metadata,\n     });\n   }\n   ```\n\n5. **Audit Dashboard**\n   - Create admin page to view audit logs\n   - Filter by user, date range, action type\n   - Export logs for compliance (HIPAA, SOX, ISO 27001)",
        "testStrategy": "Perform sensitive operations (login, role change, document delete) and verify audit_logs entries. Check IP address and user agent captured. Test trigger-based logging on critical tables. Query audit logs for specific user activity trail. Verify RLS prevents users from viewing others' audit logs. Test log export functionality.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2026-01-05T13:10:48.651Z"
      },
      {
        "id": "5",
        "title": "Enhance PWA install prompt with timing optimization",
        "description": "Optimize PWA install prompt timing and user experience based on engagement signals (page views, time on site, feature usage)",
        "details": "Improve PWA install prompt strategy (PWAInstallPrompt.tsx is already well-implemented):\n\n1. **Smart Timing Logic (src/hooks/usePWAInstall.ts)**\n   ```typescript\n   // Show prompt after user demonstrates engagement:\n   const shouldShowPrompt = (\n     pageViews >= 3 || // Visited 3+ pages\n     timeOnSite >= 60000 || // 1 minute on site\n     completedAction // Created report/RFI/submittal\n   ) && !isDismissed && !isInstalled;\n   ```\n\n2. **Engagement Tracking**\n   - Track page view count (localStorage)\n   - Measure time on site (session duration)\n   - Track feature usage (daily report created, document uploaded)\n   - Defer prompt until user is engaged\n\n3. **A/B Testing Different Timings**\n   - Variant A: Show after 3 page views\n   - Variant B: Show after 1 minute\n   - Variant C: Show after completing first task\n   - Track conversion rates for each variant\n\n4. **Platform-Specific Optimizations**\n   - **iOS**: Show Safari-specific instructions immediately (already implemented)\n   - **Android**: Use native `beforeinstallprompt` event\n   - **Desktop**: Show less aggressively (5+ page views)\n\n5. **User Preferences**\n   - Respect \"Don't show again\" for 30 days\n   - Re-show if user clears browser data\n   - Add setting to manually trigger install flow\n\n6. **Analytics Integration**\n   ```typescript\n   onAnalyticsEvent?.('pwa_prompt_shown', {\n     pageViews,\n     timeOnSite,\n     trigger: 'engagement',\n   });\n   ```",
        "testStrategy": "Test prompt appears after 3 page navigations. Verify 1-minute timer triggers prompt. Test \"Don't show again\" persists 30 days. Validate iOS shows Safari instructions. Check Android shows native prompt. Monitor analytics events (pwa_prompt_shown, pwa_installed, pwa_dismissed). A/B test different timing strategies and measure install conversion rate.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Implement push notification opt-in flow",
        "description": "Create user-friendly push notification permission request flow with clear value proposition and granular preferences",
        "details": "Build push notification opt-in experience (pushService.ts already exists):\n\n1. **Onboarding Flow (src/components/onboarding/PushNotificationOptIn.tsx)**\n   ```typescript\n   // Show after PWA install or on first login\n   export function PushNotificationOptIn() {\n     return (\n       <Card>\n         <CardHeader>\n           <Bell className=\"h-12 w-12 text-primary\" />\n           <h2>Stay Updated</h2>\n           <p>Get notified when:</p>\n           <ul>\n             <li>RFIs need your response</li>\n             <li>Submittals are approved</li>\n             <li>Daily reports are submitted</li>\n             <li>Safety incidents occur</li>\n           </ul>\n         </CardHeader>\n         <CardFooter>\n           <Button onClick={enableNotifications}>Enable Notifications</Button>\n           <Button variant=\"ghost\" onClick={skipForNow}>Skip for now</Button>\n         </CardFooter>\n       </Card>\n     );\n   }\n   ```\n\n2. **Permission Request Strategy**\n   - Never request on first page load (jarring UX)\n   - Show value proposition before requesting permission\n   - Explain what notifications user will receive\n   - Make opt-in optional, not required\n\n3. **Graceful Permission Denial**\n   - If user denies, show instructions to re-enable in browser settings\n   - Provide fallback to in-app notifications\n   - Don't repeatedly ask (respect user choice)\n\n4. **Settings Integration (src/pages/settings/NotificationsPage.tsx)**\n   - Toggle for enabling/disabling push notifications\n   - Show current permission state (granted/denied/default)\n   - Link to browser settings if denied\n   - Test notification button\n\n5. **Platform-Specific Handling**\n   - **iOS**: Explain Safari-only limitation\n   - **Android**: Use native permission prompt\n   - **Desktop**: Show browser-native prompt\n\n6. **Subscription Management**\n   - Store subscription in push_subscriptions table (migration 118)\n   - Handle subscription expiration\n   - Auto-resubscribe on expiry\n   - Track subscription across devices",
        "testStrategy": "Navigate through onboarding and verify opt-in screen appears. Click \"Enable Notifications\" and verify browser permission prompt. Test \"Skip for now\" dismisses without asking. Deny permission and verify fallback message. Re-enable from settings and verify subscription created in push_subscriptions table. Send test notification and verify delivery. Test across iOS Safari, Android Chrome, Desktop Chrome.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Build notification preferences UI with granular controls",
        "description": "Create comprehensive notification settings page allowing users to customize which events trigger push notifications, email, and in-app alerts",
        "details": "Implement notification preferences UI:\n\n1. **Notification Categories**\n   - **RFIs**: New RFI, Response added, Ball-in-court change, Overdue\n   - **Submittals**: New submittal, Status change, Approval needed, Revision uploaded\n   - **Change Orders**: New CO, Approval needed, Cost impact\n   - **Daily Reports**: Report submitted, Weather delays, Safety incidents\n   - **Tasks**: Assigned to me, Due soon, Overdue\n   - **Safety**: Incident reported, OSHA violation, Toolbox talk scheduled\n   - **Documents**: Document shared, Markup added, Version uploaded\n\n2. **Notification Channels**\n   - Push notifications (mobile/desktop)\n   - Email notifications\n   - In-app notifications (bell icon)\n   - SMS (future enhancement)\n\n3. **Preferences UI (src/pages/settings/NotificationPreferencesPage.tsx)**\n   ```typescript\n   interface NotificationPreference {\n     category: string;\n     event: string;\n     push: boolean;\n     email: boolean;\n     inApp: boolean;\n   }\n   \n   // Matrix UI with toggles for each channel\n   <Table>\n     <TableHeader>\n       <TableRow>\n         <TableHead>Event</TableHead>\n         <TableHead>Push</TableHead>\n         <TableHead>Email</TableHead>\n         <TableHead>In-App</TableHead>\n       </TableRow>\n     </TableHeader>\n     <TableBody>\n       {preferences.map(pref => (\n         <TableRow key={pref.event}>\n           <TableCell>{pref.event}</TableCell>\n           <TableCell><Switch checked={pref.push} /></TableCell>\n           <TableCell><Switch checked={pref.email} /></TableCell>\n           <TableCell><Switch checked={pref.inApp} /></TableCell>\n         </TableRow>\n       ))}\n     </TableBody>\n   </Table>\n   ```\n\n4. **Quick Presets**\n   - \"All Notifications\" - Enable everything\n   - \"Critical Only\" - Safety, overdue items, approvals\n   - \"Silent\" - Disable all\n   - \"Daily Digest\" - Batch into daily email\n\n5. **Database Schema (users.push_notification_preferences)**\n   ```json\n   {\n     \"rfis\": {\n       \"new_rfi\": { \"push\": true, \"email\": true, \"inApp\": true },\n       \"response_added\": { \"push\": true, \"email\": false, \"inApp\": true },\n       \"ball_in_court\": { \"push\": true, \"email\": true, \"inApp\": true },\n       \"overdue\": { \"push\": true, \"email\": true, \"inApp\": true }\n     },\n     \"submittals\": { ... },\n     \"safety\": { ... }\n   }\n   ```\n\n6. **Real-time Preview**\n   - Show sample notification when toggling setting\n   - \"Send test notification\" button\n   - Estimated notification volume (\"~5 per day\")",
        "testStrategy": "Open notification preferences page. Toggle individual notification channels and verify state persists. Select \"Critical Only\" preset and verify only critical notifications enabled. Send test notifications for each category. Verify preferences saved to users.push_notification_preferences JSONB column. Test that actual notifications respect preferences (create RFI, verify only configured channels notify).",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Add app badge updates for unread notifications",
        "description": "Implement app badge counter showing unread notification count on PWA home screen icon",
        "details": "Implement PWA badge API for unread counts:\n\n1. **Badge API Integration (src/lib/notifications/badge-service.ts)**\n   ```typescript\n   export class BadgeService {\n     async setBadge(count: number): Promise<void> {\n       if ('setAppBadge' in navigator) {\n         try {\n           if (count > 0) {\n             await navigator.setAppBadge(count);\n           } else {\n             await navigator.clearAppBadge();\n           }\n         } catch (error) {\n           console.error('Badge API error:', error);\n         }\n       }\n     }\n   \n     async clearBadge(): Promise<void> {\n       if ('clearAppBadge' in navigator) {\n         await navigator.clearAppBadge();\n       }\n     }\n   }\n   ```\n\n2. **Unread Count Query**\n   ```sql\n   SELECT COUNT(*) FROM notifications\n   WHERE user_id = auth.uid()\n   AND read_at IS NULL;\n   ```\n\n3. **Auto-Update Logic**\n   - Update badge when new notification arrives (push handler)\n   - Clear badge when user opens notification\n   - Update badge on app focus (handle background notifications)\n   - Sync badge across tabs using BroadcastChannel\n\n4. **Service Worker Integration (public/sw.js)**\n   ```javascript\n   self.addEventListener('push', (event) => {\n     const data = event.data.json();\n     \n     // Show notification\n     self.registration.showNotification(data.title, data.options);\n     \n     // Update badge\n     if (self.registration.setAppBadge) {\n       self.registration.setAppBadge(data.unreadCount || 1);\n     }\n   });\n   \n   self.addEventListener('notificationclick', (event) => {\n     // Clear badge on click\n     if (self.registration.clearAppBadge) {\n       self.registration.clearAppBadge();\n     }\n   });\n   ```\n\n5. **Platform Support**\n   - Chrome 81+ (Android, Desktop, ChromeOS)\n   - Edge 81+\n   - Safari 16.4+ (macOS only, not iOS)\n   - Gracefully degrade if unsupported\n\n6. **Realtime Sync**\n   - Subscribe to notifications table changes\n   - Update badge instantly when new notification inserted\n   - Handle mark-as-read updates",
        "testStrategy": "Install PWA on Android/Desktop Chrome. Create notification and verify badge shows \"1\". Create second notification and verify badge shows \"2\". Open notification and verify badge decrements. Mark all as read and verify badge clears. Test across multiple tabs. Verify badge persists after app close/reopen. Test on unsupported browsers (iOS Safari) and verify graceful degradation.",
        "priority": "low",
        "dependencies": [
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Create offline page fallback for network failures",
        "description": "Design and implement user-friendly offline fallback page when network is unavailable and content isn't cached",
        "details": "Build offline page fallback (already have service worker):\n\n1. **Offline Page (public/offline.html)**\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\">\n   <head>\n     <meta charset=\"UTF-8\">\n     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n     <title>JobSight - Offline</title>\n     <style>\n       /* Inline critical CSS (no external dependencies) */\n       body {\n         font-family: system-ui, -apple-system, sans-serif;\n         display: flex;\n         align-items: center;\n         justify-content: center;\n         min-height: 100vh;\n         margin: 0;\n         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n       }\n       .offline-container {\n         text-align: center;\n         padding: 2rem;\n         background: white;\n         border-radius: 1rem;\n         box-shadow: 0 20px 60px rgba(0,0,0,0.3);\n       }\n     </style>\n   </head>\n   <body>\n     <div class=\"offline-container\">\n       <svg><!-- Inline offline icon SVG --></svg>\n       <h1>You're Offline</h1>\n       <p>It looks like you've lost your internet connection.</p>\n       <p>Don't worry - your data is safe. We'll sync when you're back online.</p>\n       <button onclick=\"location.reload()\">Try Again</button>\n     </div>\n   </body>\n   </html>\n   ```\n\n2. **Service Worker Fallback (public/sw.js)**\n   ```javascript\n   // Cache offline page during install\n   const OFFLINE_URL = '/offline.html';\n   \n   self.addEventListener('install', (event) => {\n     event.waitUntil(\n       caches.open('offline-v1').then(cache => cache.add(OFFLINE_URL))\n     );\n   });\n   \n   // Serve offline page when fetch fails\n   self.addEventListener('fetch', (event) => {\n     if (event.request.mode === 'navigate') {\n       event.respondWith(\n         fetch(event.request).catch(() => \n           caches.match(OFFLINE_URL)\n         )\n       );\n     }\n   });\n   ```\n\n3. **Offline Page Features**\n   - Show pending sync queue count\n   - List recently accessed projects (from cache)\n   - Provide quick links to cached pages\n   - Display network status (checking for connection)\n   - Auto-reload when connection restored\n\n4. **Enhanced Offline Detection (src/hooks/useNetworkStatus.ts)**\n   ```typescript\n   export function useNetworkStatus() {\n     const [isOnline, setIsOnline] = useState(navigator.onLine);\n     \n     useEffect(() => {\n       const handleOnline = () => setIsOnline(true);\n       const handleOffline = () => setIsOnline(false);\n       \n       window.addEventListener('online', handleOnline);\n       window.addEventListener('offline', handleOffline);\n       \n       return () => {\n         window.removeEventListener('online', handleOnline);\n         window.removeEventListener('offline', handleOffline);\n       };\n     }, []);\n     \n     return isOnline;\n   }\n   ```\n\n5. **Offline Banner**\n   - Show persistent banner when offline (already exists: OfflineIndicator.tsx)\n   - Display sync queue status\n   - Show \"X items pending sync\"",
        "testStrategy": "Enable service worker. Navigate to uncached page with DevTools offline mode. Verify offline.html displays. Check offline page UI is user-friendly. Test \"Try Again\" button. Disable offline mode and verify auto-reconnect. Test with airplane mode on mobile device. Verify cached pages still load offline. Check sync queue displays on offline page.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Implement web share target for receiving files",
        "description": "Enable JobSight PWA to receive shared files (photos, PDFs) from other apps via native share sheet",
        "details": "Implement Web Share Target API for receiving files:\n\n1. **Manifest Configuration (public/manifest.json)**\n   ```json\n   {\n     \"share_target\": {\n       \"action\": \"/share-target\",\n       \"method\": \"POST\",\n       \"enctype\": \"multipart/form-data\",\n       \"params\": {\n         \"title\": \"title\",\n         \"text\": \"text\",\n         \"url\": \"url\",\n         \"files\": [\n           {\n             \"name\": \"files\",\n             \"accept\": [\"image/*\", \"application/pdf\", \".dwg\", \".dxf\"]\n           }\n         ]\n       }\n     }\n   }\n   ```\n\n2. **Share Target Handler (src/pages/ShareTargetPage.tsx)**\n   ```typescript\n   export function ShareTargetPage() {\n     const location = useLocation();\n     const navigate = useNavigate();\n     \n     useEffect(() => {\n       const params = new URLSearchParams(location.search);\n       const title = params.get('title');\n       const text = params.get('text');\n       \n       // Handle received files\n       handleSharedFiles(params);\n     }, []);\n     \n     async function handleSharedFiles(params: URLSearchParams) {\n       // Extract files from FormData\n       const formData = await request.formData();\n       const files = formData.getAll('files');\n       \n       // Store files temporarily\n       await storeSharedFiles(files);\n       \n       // Navigate to upload UI\n       navigate('/photos/upload?source=share');\n     }\n   }\n   ```\n\n3. **Use Cases**\n   - Share photo from Camera app → JobSight daily report\n   - Share PDF from Email → JobSight documents\n   - Share drawing from CAD app → JobSight markup\n\n4. **Service Worker Handler (public/sw.js)**\n   ```javascript\n   self.addEventListener('fetch', (event) => {\n     const url = new URL(event.request.url);\n     \n     if (url.pathname === '/share-target') {\n       event.respondWith(\n         (async () => {\n           const formData = await event.request.formData();\n           const files = formData.getAll('files');\n           \n           // Cache files for processing\n           const cache = await caches.open('shared-files');\n           await cache.put('/shared-files-data', \n             new Response(JSON.stringify({ files, timestamp: Date.now() }))\n           );\n           \n           // Redirect to app\n           return Response.redirect('/photos/upload?source=share', 303);\n         })()\n       );\n     }\n   });\n   ```\n\n5. **Platform Support**\n   - Android Chrome 76+\n   - ChromeOS 89+\n   - Not supported on iOS (yet)\n\n6. **User Flow**\n   1. User takes photo in Camera app\n   2. Taps \"Share\" → JobSight appears in share sheet\n   3. Select JobSight\n   4. JobSight opens to upload screen with photo pre-loaded\n   5. User selects project and adds to daily report",
        "testStrategy": "Install PWA on Android device. Take photo in Camera app. Tap Share button and verify JobSight appears in share targets. Share photo to JobSight. Verify app opens to upload screen with photo. Test sharing PDF from email. Test sharing multiple files. Verify files stored temporarily before upload. Test graceful handling if user cancels upload.",
        "priority": "low",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Build RFI ball-in-court notification system",
        "description": "Implement notification system that alerts users when an RFI ball-in-court status changes, requiring their action",
        "details": "Implement ball-in-court notifications (RFI tracking already exists):\n\n1. **Ball-in-Court Trigger (supabase/migrations/171_rfi_ball_in_court_notifications.sql)**\n   ```sql\n   -- Trigger when RFI ball_in_court changes\n   CREATE OR REPLACE FUNCTION notify_rfi_ball_in_court_change()\n   RETURNS TRIGGER AS $$\n   DECLARE\n     responsible_users UUID[];\n   BEGIN\n     -- Determine who needs notification based on ball_in_court value\n     responsible_users := CASE NEW.ball_in_court\n       WHEN 'architect' THEN get_project_architects(NEW.project_id)\n       WHEN 'engineer' THEN get_project_engineers(NEW.project_id)\n       WHEN 'contractor' THEN get_project_contractors(NEW.project_id)\n       WHEN 'owner' THEN get_project_owners(NEW.project_id)\n       ELSE ARRAY[]::UUID[]\n     END;\n     \n     -- Create notifications for responsible users\n     INSERT INTO notifications (user_id, type, title, body, related_to_type, related_to_id, data)\n     SELECT \n       unnest(responsible_users),\n       'rfi_ball_in_court',\n       'RFI #' || NEW.number || ' needs your response',\n       'Subject: ' || NEW.subject,\n       'rfi',\n       NEW.id,\n       jsonb_build_object(\n         'rfi_number', NEW.number,\n         'project_id', NEW.project_id,\n         'ball_in_court', NEW.ball_in_court,\n         'due_date', NEW.due_date\n       );\n     \n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql;\n   \n   CREATE TRIGGER rfi_ball_in_court_notification\n     AFTER INSERT OR UPDATE OF ball_in_court ON rfis\n     FOR EACH ROW\n     WHEN (OLD.ball_in_court IS DISTINCT FROM NEW.ball_in_court)\n     EXECUTE FUNCTION notify_rfi_ball_in_court_change();\n   ```\n\n2. **Push Notification Sender (supabase/functions/send-rfi-notification/index.ts)**\n   ```typescript\n   import { sendPushNotification } from '../_shared/push-sender.ts';\n   \n   Deno.serve(async (req) => {\n     const { rfiId, userId, ballInCourt } = await req.json();\n     \n     // Get user's push subscriptions\n     const subscriptions = await getUserPushSubscriptions(userId);\n     \n     // Send push notification to all subscriptions\n     await Promise.all(\n       subscriptions.map(sub =>\n         sendPushNotification(sub, {\n           title: `RFI needs your response`,\n           body: `You are responsible for responding to RFI #${rfiNumber}`,\n           tag: `rfi-${rfiId}`,\n           data: { url: `/rfis/${rfiId}`, type: 'rfi_ball_in_court' },\n           requireInteraction: true,\n         })\n       )\n     );\n   });\n   ```\n\n3. **Email Notification Template (src/lib/email/templates/rfi-ball-in-court.ts)**\n   ```typescript\n   export function getRFIBallInCourtEmail(rfi: RFI, user: User) {\n     return {\n       subject: `Action Required: RFI #${rfi.number} - ${rfi.subject}`,\n       html: `\n         <h2>RFI #${rfi.number} needs your response</h2>\n         <p>The ball is in your court for the following RFI:</p>\n         <ul>\n           <li><strong>Subject:</strong> ${rfi.subject}</li>\n           <li><strong>Project:</strong> ${rfi.project.name}</li>\n           <li><strong>Due Date:</strong> ${formatDate(rfi.due_date)}</li>\n         </ul>\n         <a href=\"${getAppURL()}/rfis/${rfi.id}\">View RFI</a>\n       `,\n     };\n   }\n   ```\n\n4. **In-App Notification (src/features/notifications/components/RFIBallInCourtNotification.tsx)**\n   - Show prominent badge on RFIs page\n   - Filter view for \"My Ball-in-Court RFIs\"\n   - Sort by due date (urgent first)\n\n5. **Notification Channels**\n   - Push notification (if enabled)\n   - Email (if enabled in preferences)\n   - In-app notification bell\n   - Dashboard widget showing ball-in-court count\n\n6. **Overdue Escalation**\n   - Send reminder 2 days before due date\n   - Send urgent notification on due date\n   - Escalate to supervisor if 3 days overdue",
        "testStrategy": "Create RFI and assign to architect. Verify architect receives push, email, and in-app notification. Change ball-in-court to contractor. Verify contractor notified and architect notification cleared. Test notification preferences (push-only, email-only). Set RFI due date to tomorrow. Verify reminder notification sent. Test overdue escalation after 3 days. Check dashboard widget shows correct count.",
        "priority": "high",
        "dependencies": [
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Create submittal revision comparison view",
        "description": "Build side-by-side comparison UI for reviewing changes between submittal revisions",
        "details": "Implement submittal revision comparison (based on existing DrawingRevisionComparison.tsx):\n\n1. **Comparison Component (src/features/submittals/components/SubmittalRevisionComparison.tsx)**\n   ```typescript\n   export function SubmittalRevisionComparison({\n     submittalId,\n     revisionA,\n     revisionB,\n   }: Props) {\n     const { data: compareData } = useQuery({\n       queryKey: ['submittal-revision-compare', submittalId, revisionA, revisionB],\n       queryFn: () => compareSubmittalRevisions(submittalId, revisionA, revisionB),\n     });\n     \n     return (\n       <div className=\"grid grid-cols-2 gap-4\">\n         <div className=\"border rounded-lg p-4\">\n           <h3>Revision {revisionA}</h3>\n           <SubmittalRevisionViewer revision={compareData.revisionA} />\n         </div>\n         <div className=\"border rounded-lg p-4\">\n           <h3>Revision {revisionB}</h3>\n           <SubmittalRevisionViewer revision={compareData.revisionB} />\n         </div>\n       </div>\n     );\n   }\n   ```\n\n2. **Comparison Features**\n   - Side-by-side PDF viewer (if submittal is PDF)\n   - Highlight changed fields (status, shop drawings, notes)\n   - Show metadata differences (upload date, reviewer, comments)\n   - Link to previous/next revision\n   - Download both revisions\n\n3. **Visual Diff for PDFs**\n   - Use pixelmatch library (already in package.json)\n   - Render both PDFs to canvas\n   - Overlay diff highlighting changes in red\n   - Zoom and pan synchronized\n\n4. **Field Changes Table**\n   ```typescript\n   <Table>\n     <TableHeader>\n       <TableRow>\n         <TableHead>Field</TableHead>\n         <TableHead>Revision {revisionA}</TableHead>\n         <TableHead>Revision {revisionB}</TableHead>\n       </TableRow>\n     </TableHeader>\n     <TableBody>\n       {changes.map(change => (\n         <TableRow key={change.field}>\n           <TableCell>{change.field}</TableCell>\n           <TableCell className={change.changed ? 'bg-red-50' : ''}>\n             {change.oldValue}\n           </TableCell>\n           <TableCell className={change.changed ? 'bg-green-50' : ''}>\n             {change.newValue}\n           </TableCell>\n         </TableRow>\n       ))}\n     </TableBody>\n   </Table>\n   ```\n\n5. **Database Query**\n   ```sql\n   -- Get submittal revision history\n   SELECT \n     sr.*,\n     u.full_name as uploaded_by_name,\n     array_agg(c.comment) as comments\n   FROM submittal_revisions sr\n   LEFT JOIN users u ON sr.uploaded_by = u.id\n   LEFT JOIN submittal_comments c ON c.revision_id = sr.id\n   WHERE sr.submittal_id = $1\n   GROUP BY sr.id\n   ORDER BY sr.revision_number DESC;\n   ```\n\n6. **UI/UX Enhancements**\n   - Revision timeline slider\n   - \"Compare to previous\" quick action\n   - Keyboard shortcuts (arrow keys to navigate revisions)\n   - Mobile-responsive (stack vertically on small screens)",
        "testStrategy": "Create submittal with 3 revisions. Open comparison view for rev 1 vs rev 3. Verify side-by-side layout. Test PDF diff highlighting. Check field changes table shows differences. Test timeline slider navigates revisions. Verify mobile layout stacks vertically. Download both PDFs and verify correct versions. Test keyboard shortcuts. Compare identical revisions and verify \"No changes\" message.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "Add cost/schedule impact tracking for RFIs",
        "description": "Enable users to estimate and track cost and schedule impacts of RFIs with approval workflows for significant impacts",
        "details": "Implement RFI impact tracking:\n\n1. **Database Schema (supabase/migrations/172_rfi_impact_tracking.sql)**\n   ```sql\n   ALTER TABLE rfis ADD COLUMN IF NOT EXISTS cost_impact DECIMAL(12, 2) DEFAULT 0;\n   ALTER TABLE rfis ADD COLUMN IF NOT EXISTS schedule_impact_days INTEGER DEFAULT 0;\n   ALTER TABLE rfis ADD COLUMN IF NOT EXISTS impact_justification TEXT;\n   ALTER TABLE rfis ADD COLUMN IF NOT EXISTS impact_approved_by UUID REFERENCES auth.users(id);\n   ALTER TABLE rfis ADD COLUMN IF NOT EXISTS impact_approved_at TIMESTAMPTZ;\n   \n   -- Track impact history\n   CREATE TABLE rfi_impact_history (\n     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n     rfi_id UUID NOT NULL REFERENCES rfis(id) ON DELETE CASCADE,\n     previous_cost_impact DECIMAL(12, 2),\n     new_cost_impact DECIMAL(12, 2),\n     previous_schedule_impact INTEGER,\n     new_schedule_impact INTEGER,\n     changed_by UUID REFERENCES auth.users(id),\n     justification TEXT,\n     created_at TIMESTAMPTZ DEFAULT NOW()\n   );\n   ```\n\n2. **Impact Input UI (src/features/rfis/components/RFIImpactForm.tsx)**\n   ```typescript\n   export function RFIImpactForm({ rfi, onSave }: Props) {\n     return (\n       <Form onSubmit={handleSubmit}>\n         <FormField label=\"Estimated Cost Impact\">\n           <Input\n             type=\"number\"\n             prefix=\"$\"\n             value={costImpact}\n             onChange={setCostImpact}\n           />\n         </FormField>\n         \n         <FormField label=\"Schedule Impact (Days)\">\n           <Input\n             type=\"number\"\n             suffix=\"days\"\n             value={scheduleImpact}\n             onChange={setScheduleImpact}\n           />\n         </FormField>\n         \n         <FormField label=\"Justification\">\n           <Textarea\n             rows={4}\n             placeholder=\"Explain the impact on cost and schedule...\"\n             value={justification}\n             onChange={setJustification}\n           />\n         </FormField>\n         \n         {(costImpact > 10000 || scheduleImpact > 7) && (\n           <Alert variant=\"warning\">\n             This impact requires approval from a Project Manager\n           </Alert>\n         )}\n       </Form>\n     );\n   }\n   ```\n\n3. **Approval Workflow**\n   - Impacts < $10k or < 7 days: Auto-approved\n   - Impacts ≥ $10k or ≥ 7 days: Requires PM approval\n   - Notify PM when approval needed\n   - Track approval status on RFI detail page\n\n4. **Impact Dashboard Widget**\n   ```typescript\n   // Show total impact across all open RFIs\n   SELECT \n     SUM(cost_impact) as total_cost_impact,\n     SUM(schedule_impact_days) as total_schedule_impact,\n     COUNT(*) FILTER (WHERE cost_impact > 0) as rfis_with_cost_impact\n   FROM rfis\n   WHERE status != 'closed'\n   AND project_id = $1;\n   ```\n\n5. **Change Order Integration**\n   - \"Create Change Order from RFI\" button\n   - Pre-populate CO with RFI impact amounts\n   - Link CO to originating RFI\n\n6. **Reports**\n   - RFI impact summary by project\n   - Impact trend over time\n   - Export to Excel for budget tracking",
        "testStrategy": "Create RFI with $5k cost impact and 3 day schedule impact. Verify auto-approved. Create RFI with $15k impact. Verify PM approval required and PM notified. Approve impact as PM. Test impact history tracks changes. View dashboard widget showing total impact across RFIs. Create change order from RFI and verify amounts pre-populated. Export impact report and verify Excel format.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Implement email distribution workflows",
        "description": "Build email distribution system for RFIs, submittals, and change orders with distribution lists and automated routing",
        "details": "Implement email distribution (distribution_lists already exists - migration 085):\n\n1. **Distribution List UI (src/features/distribution-lists/components/DistributionListManager.tsx)**\n   ```typescript\n   export function DistributionListManager({ projectId }: Props) {\n     const { data: lists } = useDistributionLists(projectId);\n     \n     return (\n       <div>\n         <h2>Distribution Lists</h2>\n         {lists.map(list => (\n           <DistributionListCard key={list.id} list={list}>\n             <h3>{list.name}</h3>\n             <p>{list.recipients.length} recipients</p>\n             <ul>\n               {list.recipients.map(recipient => (\n                 <li>{recipient.email} ({recipient.role})</li>\n               ))}\n             </ul>\n           </DistributionListCard>\n         ))}\n         <Button onClick={createNewList}>Create Distribution List</Button>\n       </div>\n     );\n   }\n   ```\n\n2. **Distribution Selection (src/features/rfis/components/RFIDistributionSelector.tsx)**\n   ```typescript\n   // When creating/updating RFI\n   <FormField label=\"Send Email To\">\n     <MultiSelect\n       options={[\n         { label: 'Architect Team', value: 'dist_list_architect' },\n         { label: 'Engineering Team', value: 'dist_list_engineer' },\n         { label: 'Contractor Team', value: 'dist_list_contractor' },\n       ]}\n       value={selectedLists}\n       onChange={setSelectedLists}\n     />\n     <div className=\"mt-2\">\n       <Checkbox>\n         <label>Send email notifications</label>\n       </Checkbox>\n     </div>\n   </FormField>\n   ```\n\n3. **Email Templates**\n   - RFI Created: \"New RFI #123 - Subject\"\n   - RFI Response: \"RFI #123 Response from Architect\"\n   - Submittal Submitted: \"Submittal #456 - Spec Section 03 30 00\"\n   - Submittal Approved: \"Submittal #456 Approved\"\n   - Change Order: \"Change Order #789 - Description\"\n\n4. **Edge Function (supabase/functions/send-distribution-email/index.ts)**\n   ```typescript\n   Deno.serve(async (req) => {\n     const { listId, subject, body, attachments } = await req.json();\n     \n     // Get distribution list recipients\n     const recipients = await getDistributionListRecipients(listId);\n     \n     // Send email to all recipients\n     await Promise.all(\n       recipients.map(recipient =>\n         sendEmail({\n           to: recipient.email,\n           subject,\n           html: body,\n           attachments,\n         })\n       )\n     );\n     \n     // Log email sent\n     await logEmailDistribution(listId, recipients.length);\n   });\n   ```\n\n5. **Automated Routing Rules**\n   - RFI status change → Notify ball-in-court distribution list\n   - Submittal submitted → Notify reviewer distribution list\n   - Change order created → Notify approval chain\n   - Daily report submitted → Notify management team\n\n6. **Email Preferences**\n   - User can opt-out of specific distribution lists\n   - Digest mode (daily summary instead of individual emails)\n   - Reply-to handling (replies create comments)",
        "testStrategy": "Create distribution list with 3 recipients. Create RFI and select distribution list. Verify all 3 recipients receive email. Test email template formatting. Update RFI status and verify automated routing. Test user opt-out from list. Enable digest mode and verify daily summary sent. Reply to RFI email and verify comment created. Check email logs for delivery status.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Optimize query performance for large projects",
        "description": "Analyze and optimize slow database queries, add strategic indexes, and implement query result caching for projects with 1000+ items",
        "details": "Performance optimization for scale:\n\n1. **Query Analysis**\n   ```sql\n   -- Enable query logging in Supabase dashboard\n   -- Identify slow queries (>100ms)\n   SELECT \n     query,\n     calls,\n     total_time,\n     mean_time,\n     max_time\n   FROM pg_stat_statements\n   ORDER BY mean_time DESC\n   LIMIT 20;\n   ```\n\n2. **Strategic Indexes (supabase/migrations/173_performance_indexes.sql)**\n   ```sql\n   -- RFI queries\n   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_rfis_project_status \n     ON rfis(project_id, status) WHERE deleted_at IS NULL;\n   \n   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_rfis_ball_in_court \n     ON rfis(project_id, ball_in_court) WHERE status != 'closed';\n   \n   -- Submittal queries\n   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_submittals_project_spec \n     ON submittals(project_id, spec_section);\n   \n   -- Daily reports\n   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_daily_reports_project_date \n     ON daily_reports(project_id, report_date DESC);\n   \n   -- Documents with full-text search\n   CREATE INDEX IF NOT EXISTS idx_documents_search \n     ON documents USING GIN(to_tsvector('english', name || ' ' || COALESCE(description, '')));\n   \n   -- Composite indexes for common filters\n   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tasks_assignee_status_due \n     ON tasks(assignee_id, status, due_date) WHERE deleted_at IS NULL;\n   ```\n\n3. **Query Optimization Examples**\n   ```typescript\n   // Before: N+1 query problem\n   const rfis = await supabase.from('rfis').select('*');\n   for (const rfi of rfis.data) {\n     const responses = await supabase.from('rfi_responses')\n       .select('*')\n       .eq('rfi_id', rfi.id);\n   }\n   \n   // After: Single query with join\n   const rfis = await supabase\n     .from('rfis')\n     .select(`\n       *,\n       responses:rfi_responses(*)\n     `);\n   ```\n\n4. **React Query Caching**\n   ```typescript\n   // Increase staleTime for infrequently changing data\n   export function useProjects() {\n     return useQuery({\n       queryKey: ['projects'],\n       queryFn: fetchProjects,\n       staleTime: 5 * 60 * 1000, // 5 minutes\n       cacheTime: 30 * 60 * 1000, // 30 minutes\n     });\n   }\n   ```\n\n5. **Pagination & Virtual Scrolling**\n   - Already using @tanstack/react-virtual (package.json)\n   - Implement for long lists (RFIs, submittals, documents)\n   - Limit initial fetch to 50 items\n   - Load more on scroll\n\n6. **Database Connection Pooling**\n   - Configure Supabase pooler settings\n   - Max connections: 100\n   - Statement timeout: 30s\n\n7. **Performance Monitoring**\n   - Add timing metrics to TanStack Query\n   - Track slow queries in Sentry\n   - Dashboard widget showing query performance",
        "testStrategy": "Run EXPLAIN ANALYZE on top 10 queries. Create test project with 1000 RFIs, 500 submittals, 2000 documents. Measure query times before optimization. Add indexes and re-measure (target: <100ms). Test pagination loads 50 items initially. Verify virtual scrolling smooth with 1000+ items. Monitor TanStack Query DevTools for cache hits. Use Lighthouse to measure page load time (target: <3s).",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-05T13:10:48.653Z",
      "taskCount": 15,
      "completedCount": 3,
      "tags": [
        "master"
      ]
    }
  }
}